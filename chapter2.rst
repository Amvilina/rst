Глава 2. Задача про биржевой сбор
---------------------------------

Нужно написать простую логику сервиса:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  - Входной поток - Сделка ``( id, время сделки, цена, количество )``
  - Выходной поток - Комиссия ``( id, время сделки, значение = цена * количество * 1% )``
  - Задача состоит из 5 пунктов:

    - Описание входной и выходной схемы данных
    - Подготовка входных данных
    - Логика обработки сообщений ( python )
    - Конфиг процессора сервиса
    - Запуск и проверка работы
  - Рекомендую создать тестовую директорию у себя и уже в ней создавать файлы: ``$ mkdir my-example``, ``$ cd my-example``


|


Описание входной и выходной схемы данных
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  - Сделка / Transaction представляет собой файл с расширением ``.yaml`` в котором описана схема входного сообщения 
  - Файл в Linux можно создать командой: ``$ touch [имя_файла]``
  - Файлы, связанные с сообщениями, будем хранить в папке ``$ mkdir messages``
  - ``./messages/transaction.yaml``:

    .. code:: yaml

          - name: Transaction           # Имя нашего сообщения / входной схемы
            id: 10                      # У каждого сообщения должен быть уникальный id, чтобы оно кодировалось 

            fields:                     # Поле fields хранит в себе список полей самого сообщения
            - name: time                # Имя переменной - время сделки
              type: int64               # Настоящий тип (как хранится) - целое число
              options.type: time_point  # Опциональный тип (как обрабатывается) - временная метка 
              options.resolution: ns    # Обязательное поле для time_point, в каком формате хранится время

            - name: id                  # Id сделки
              type: int64             

            - name: price               # Цена сделки
              type: int64
              options.type: fixed2      # Обрабатывается, как вещественное с 2-мя знаками после запятой
                                        # Например хранящееся число 12345 будет обрабатываться как 123.45

            - name: count               # Количество элементов в сделке
              type: uint16

  - Аналогичным образом схема выходного сообщения описана в ``./messages/commission.yaml``:

    .. code:: yaml

          - name: Commission           # Имя сообщения   
            id: 20                     # Уникальный id 
            fields:
            - name: time               # Время сделки
              type: int64
              options.type: time_point 
              options.resolution: ns
            - name: id                 # Id сделки
              type: int64
            - name: value              # Значение комиссии
              type: int64
              options.type: fixed2
  - Поля id в сообщениях в нашем случае могут совпадать, потому что они будут обрабатываться в разных потоках: входном и выходном, однако best-practice так не делать :)


Подготовка входных данных
^^^^^^^^^^^^^^^^^^^^^^^^^

  - Входные данные для нашего сервиса будут считываться из файла с расширением ``.yaml``, в файле должны быть описаны данные в формате сообщения ``Transaction``
  - ``input-data.yaml``:

    .. code:: yaml

          - name: Transaction                     # Имя схемы / сообщения, которое мы отправляем
            data:
              time: 2024-04-24T11:04:05.123456789 # Время сделки - time_point
              id: 1                               # Id сделки - int64
              price: 113.90                       # Цена сделки - fixed2
              count: 4                            # Количество элементов в сделке - uint16
          - name: Transaction
            data:
              time: 2024-04-28T11:04:05.123456789 # -> 28 марта 2024г. 11ч. 4м. 5с. и 123456789 наносекунд
              id: 2
              price: 115.74
              count: 8
          - name: Transaction
            data:
              time: 2024-05-03T11:04:05.123456789
              id: 3
              price: 120.58
              count: 3


Логика обработки сообщений ( python )
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  - ``commission.py``:

    .. code:: python

          # Импортируем класс Logic, чтобы реализовать логику сервиса
          from tll.channel.logic import Logic 

          # Для работы с fixed2
          import decimal 

          # Чтобы описать логику сервиса нужно унаследоваться от класса Logic и реализовать 3 метода: _init, _open, _logic
          class Commission(Logic): 
          
              # Данный метод вызывается в момент создания сервиса
              # В url передаются данные о сервисе, например описание входных и выходных каналов
              # master используется для связи разных объектов в одном процессе ( например для общих переменных )
              def _init(self, url, master=None):
          
                  # Родитель обрабатывает входные параметры, в self._channels после этого хранится информация о входных/выходных каналах
                  # Переменная master никак не обрабатывается родителем, однако её стоит писать, если что-то поменяется в будущем
                  super()._init(url, master)  
                  
                  # Получаем список входных каналов и проверям, что он ровно 1
                  input_channels = self._channels.get('input', [])
                  if len(input_channels) != 1:
                      raise RuntimeError("Need exactly one input, got: {}".format([c.name for c in input_channels]))
                  
                  # Сохраняем входной канал в переменную
                  self._input = input_channels[0]
          
                  # Аналогичная процедура с выходным каналом
                  output_channels = self._channels.get('output', [])
                  if len(output_channels) != 1:
                      raise RuntimeError("Need exactly one output, got: {}".format([c.name for c in output_channels]))
                  self._output = output_channels[0]
          
              # Данный метод вызывается во время запуска сервиса
              # В props передаются параметры открытия канала ( например номер последнего сообщения seq=N )
              def _open(self, props):
            
                  # У базового класса нет никакой функциональности, там просто написано pass
                  # Но это может поменяться, поэтому лучше писать так
                  super()._open(props)
          
              # Данный метод вызывается при получении сообщении из канала
              # В channel находится канал, откуда пришло сообщение
              # В msg хранится сообщение
              def _logic(self, channel, msg):
          
                  # Проверяем, что сообщение пришло из нужного входного канала
                  if channel != self._input:
                      return
                  
                  # Проверяем, что наше сообщение именно хранит данные
                  # Ещё есть msg.Type.State, он может быть равен: 'Closed', 'Opening', 'Active', 'Closing', 'Error', 'Destroy'
                  # Ещё есть msg.Type.Control, специальное сообщение управлением канала 
                  # ( например в tcp-канале так происходит соединение и его разрыв )
                  if msg.type != msg.Type.Data:
                      return
                  
                  # Распаковываем сообщение, оно нам приходит в "бинарном" виде
                  msg = channel.unpack(msg)
          
                  # Проверяем, что наше сообщение - ожидаемый Transaction
                  if msg.SCHEME.name == 'Transaction':
          
                      # Считаем value для нашей комиссии
                      # decimal.Decimal(...) переводит число в fixed2
                      value = msg.price * msg.count * decimal.Decimal('0.01')
          
                      # Записываем сообщение в выходной канал с пометкой о том, что оно имеет вид Commission
                      self._output.post(
                          {'time': msg.time, 'id': msg.id, 'value': value}, 
                          name='Commission')
          
Конфиг процессора сервиса
^^^^^^^^^^^^^^^^^^^^^^^^^

  - Для каждого tll сервиса нужно описать конфигурацию в файле формата ``.yaml``
  - ``commission-processor.yaml``:

    .. code:: yaml

        # Описывается система логирования
        logger:
          type: spdlog # Тип используемых логов, 'spdlog' - стандартный
                       # Ещё можно написать 'python', они будут немного в другом стиле выводиться

          levels:      # Здесь будут описаны уровни логирования
                       # Их приоритеты: 'DEBUG' < 'INFO' < 'WARNING' < 'ERROR'
            tll: DEBUG # Логи ниже приоритетом не будут отображаться

        # Связываем питоновскую логику с yaml переменными
        processor.alias:
          commission: python://;python=./commission:Commission # Объявляем переменную commission
                                                               # Связываем её с классом Commission из файла commission

        # Здесь объявляются используемые объекты: входные/выходные потоки и логика
        processor.objects:
          input-channel:                      # Входной поток

            init:                             # Описываем атрибуты потока
              tll.proto: yaml                 # Данные приходят из .yaml файла
              tll.host: input-data.yaml       # Файл находится по этому адресу
              scheme: yaml://./messages/transaction.yaml # Схема входных данных (Transaction) - yaml://[имя_файла_со_схемой]
              autoseq: true                   # Каждое сообщение имеет атрибут 'seq', который мы автоматически инкрементируем
              dump: yes                       # Выводить в логи информацию о каждом сообщении, которое отправляет поток
                                              # yes - вывод метаданных и содержимого сообщения (в читаемом виде согласно scheme)

            depends: logic                    # Объекты собираются в порядке объявления, однако запускаются согласно зависимостям
                                              # Входной поток нельзя запускать, пока не запустится логика программы
                                              # Поэтому мы сообщаем это в конфиге

          output-channel:                     # Выходной поток
            init:
              tll.proto: file                 # Писать будем в простой файл
              tll.host: output.dat            # Название файла, куда запишем данные
              dir: w                          # Сообщаем, что нужно открывать файл на запись
              scheme: yaml://./messages/commission.yaml  # Записываем мы сообщение в формате Commission
              autoseq: true                   # Для записи это обязательный параметр, потому что output.txt будет проверять 'seq'
                                              # Если у нового сообщения 'seq' <= чем у последнего в файле, то будет ошибка
              dump: scheme

          logic:                              # Логика нашего сервиса
            url: commission://                # Используется processor.alias, объявленный выше
            channels:                         # Здесь описываются каналы, которые мы используем в .py файле
              input: input-channel            # Входные каналы
              output: output-channel          # Выходные каналы
            depends: output-channel           # Логика не может запуститься и начать писать в выходной канал, пока он не открыт

Запуск и проверка работы
^^^^^^^^^^^^^^^^^^^^^^^^

  - Нужные файлы собраны, осталось всё проверить, для этого запускаем команду ``$ tll-pyprocessor commission-processor.yaml``
  - Входной поток будет бесконечно считывать входные данные, в логах можно будет увидеть сообщения вида:

    .. code:: 

        2024-08-28 23:12:41.829 INFO tll.channel.input-channel: Recv message: type: Data, msgid: 10, name: Transaction, seq: 0, size: 26
          time: 2024-04-24T11:04:05.123456789
          id: 1
          price: 113.90
          count: 4

        2024-08-28 23:12:41.829 INFO tll.channel.output-channel: Post message: type: Data, msgid: 20, name: Commission, seq: 0, size: 24
          time: 2024-04-24T11:04:05.123456789
          id: 1
          value: 4.56

        ...

        2024-08-28 23:12:41.830 INFO tll.channel.input-channel: All messages processed. Closing

  - Программа будет работать бесконечно можно остановить её нажав ``^C``
  - У нас появился файл ``output.dat``, в котором хранятся выходные сообщения (в нём находятся повторяющиеся 3 сообщения, так как у нас было 3 входных объекта)
  - Посмотрим на первые 3 сообщения: ``$ tll-read output.dat --seq 0:2``
  
    .. code:: 

          - seq: 0
            name: Commission
            data:
                time: '2024-04-24T11:04:05.123456789Z'
                id: 1
                value: '4.56'
            - seq: 1
            name: Commission
            data:
                time: '2024-04-28T11:04:05.123456789Z'
                id: 2
                value: '9.26'
            - seq: 2
            name: Commission
            data:
                time: '2024-05-03T11:04:05.123456789Z'
                id: 3
                value: '3.62'
  - Всё верно:
    
    - ``113.90 * 4 * 0.01 = 4.556 -> 4.56``
    - ``115.74 * 8 * 0.01 = 9.2592 -> 9.26``
    - ``120.58 * 3 * 0.01 = 3.6174 -> 3.62``
  
  - Если посмотреть на следующие 3 сообщения ``$ tll-read output.dat --seq 3:5``, то они будут содержать такие же данные, только отличаться полем ``seq``

  - Проверим теперь фильтрацию с помощью ``tll-read``. Перед нами стоит задача выбрать все сообщения ( из 3-х возможных, в нашем случае ), для которых ``value < 5``. Для этого воспользуемся командой ``$ tll-read output.dat --filter 'seq < 3 and data.value < 5'``. После ``--filter`` мы должны в кавычках написать логическое выражение на языке ``Lua``, которое возвращает ``true`` ( печатать сообщение ) или ``false`` ( пропуск сообщения )


  .. code::

    - seq: 0
      name: Commission
      data:
        time: '2024-04-24T11:04:05.123456789Z'
        id: 1
        value: '4.56'

    - seq: 2
      name: Commission
      data:
        time: '2024-05-03T11:04:05.123456789Z'
        id: 3
        value: '3.62'

    

