Глава 7. Знакомство с config
----------------------------

  Config - способ хранения параметров инициализации, открытия и работы канала, который поддерживает возможность управлять этими параметрами из кода. Данные из ``.yaml`` файлов, где мы описывали работу процессора автоматически загружаются в конфиг соответствующих объектов. Затем в коде мы можем считывать эти данные, создавать новые разделы, записывать в них что-то. Конфиг используется в виде 'интерфейса' для передачи данных из кода в канал.

|

Config и python
^^^^^^^^^^^^^^^

  - Наш комиссионный сервис является клиентом в ``stream+pub+tcp``, у него есть параметры открытия, с помощью которых он получает исторические данные. Свяжем эти параметры открытия с кодом, ``commission-processor.py``:

    .. code:: yaml

      # ...

        input-channel:
          init:
            # ...

          # за данные открытия мы обращаемся к конфигу у объекта 'logic'
          # мы связываем параметры открытия с разделом конфига 'info'
          # в этом разделе мы создадим подраздел 'input-open-params'
          open: !link /sys/logic/info/input-open-params
          depends: logic

      # ...

  - Объект ``logic`` представляет из себя питоновский код логики, добавим в него несколько строк, ``commission.py``:

    .. code:: python

      from tll.config import Config

      # ...

          def _init(self, url, master=None):

              #...

              # создаём конфиг, который будет являться подразделом в конфиге 'info'
              requestConfig = Config()
              requestConfig["mode"] = 'seq'       # 'seq' - режим открытия
              requestConfig["seq"]  = '0'         # '0' - номер первого запрошенного сообщения

              # в раздел 'info' записываем новый раздел с именем 'input-open-params'
              self.config_info.set("input-open-params", requestConfig)

      # ...

  - Проверка будет происходить, как и в предыдущей главе: мы запускаем сервер ( генератор сделок ), ждём какое-то время, пока он сгенерирует сообщения, затем запускаем клиент ( сервис комиссий ). В логах будут написаны полученные исторические сообщения, а затем специальное сообщение ``Online``. Можно поменять номер первого сообщения в коде выше, чтобы убедиться, что всё хорошо работает
  - Усложним нашу логику: будем хранить номер последнего полученного сообщения, чтобы при закрытии канала мы могли записать его в конфиг. В момент открытия канала мы сможем считать этот номер из конфига и запросить у сервера все пропущенные из-за отсутсвия связи сообщения, начиная с запомненного номера. Таким образом мы эффективно используем наши ресурсы и не обрабатываем исторические сообщения несколько раз
  - ``commission.py``:

    .. code:: python

      # ...

          def _open(self, props):
              super()._open(props)
        

              # в момент открытия считаем из конфига нужное поле
              self._lastSeq = self.config_info["input-open-params.seq"]

              # в конфиге хранятся только строки, поэтому иррационально будет хранить данные в нём
              # мы храним данные в целочисленной переменной, которой легко манипулировать
              # если кому-то понадобится её значение, то он обратится к конфигу
              # конфиг делегирует запрос callback-функции, которая вернёт строковое представление числа
              self.config_info["input-open-params.seq"] = lambda: str(self._lastSeq)
        
        
          def _close(self):
              super()._close()
              
              # в момент закрытия мы снова обновляем значение в конфиге
              # в этот раз там будет храниться просто строка
              # канал закрыт, поэтому число меняться не будет
              # просто строка становится более эффективной
              self.config_info["input-open-params.seq"] = str(self._lastSeq)

          # в _logic(...) с каждым новым полученным сообщением мы пишем self._lastSeq = msg.seq + 1
          # self._lastSeq по факту хранит в себе номер следующего ожидаемого сообщения

      # ...

Config и С++
^^^^^^^^^^^^

  - Теперь реализуем работу с config в C++, для этого добавим возможность генератору сделок в момент открытия канала выставлять ``id`` следующего генерируемого сообщения. Обновим класс в ``transaction-generator.h``:

    .. code:: c++

      // ...

          void SetNextTransactionId( int64_t nextTransactionId ) {
              _nextTransactionId = nextTransactionId;
          }

      // ...

  - ``generator.cc``:

    .. code:: c++

      // ...

          int _init(const tll::Channel::Url &, tll::Channel *master) {

              // ...

              // создаём новый конфиг/раздел
              auto transactionGeneratorConfig = tll::Config();

              // записываем туда значение переменной
              transactionGeneratorConfig.set("next-id", "666");

              // мы можем передать туда не строку, а число, но для этого использовать функцию setT
              // transactionGeneratorConfig.setT("next-id", 666);

              // записываем в раздел 'info' конфига новый раздел
              config_info().set("transaction-generator", transactionGeneratorConfig);
        
              return 0;
          }

          int _open(const tll::ConstConfig &) {

              // вычитываем из конфига в нужный тип данных значение
              // getT возвращает tll::expected, потому что в конфиге могло не быть правильных данных
              // звёздочка возвращает нам запрошенные даныне
              auto nextId = *config_info().getT<int64_t>("transaction-generator.next-id");

              // устанавливаем значение в генераторе
              _transactionGenerator.SetNextTransactionId(nextId);
                
              return 0;
          }

      // ...
  - Callback-функции для конфига в C++ имею похожую структуру:

    .. code:: c++

      /* 
        предположим, что у нас есть переменная в классе - _nextId
        _nextId будет каждый раз увеличиваться при генерировании сообщения

        чтобы связать её с конфигом мы напишем строчку:
        config_info().set_ptr("transaction-generator.next-id", &_nextId);

        set_ptr автоматически создаёт callback-функцию, которая берёт значение по ссылке,
        а затем переводит его в C-строку и возвращает

        В таком формате код немного поменяется:
      */

      // ...

          int _open(const tll::ConstConfig &) {
              _nextId = *config_info().getT<int64_t>("transaction-generator.next-id");
              _transactionGenerator.SetNextTransactionId(_nextId);
                
              config_info().set_ptr("transaction-generator.next-id", &_nextId);
              
              return 0;
          }
          
          int _close() {
              config_info().setT("transaction-generator.next-id", _nextId);
              return 0;
          }

      // ...
