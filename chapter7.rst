Глава 7. Знакомство с config
----------------------------

  Config - способ хранения параметров инициализации, открытия и работы канала, который поддерживает возможность управлять этими параметрами из кода. Данные из ``.yaml`` файлов, где мы описывали работу процессора автоматически загружаются в конфиг соответствующих объектов. Затем в коде мы можем считывать эти данные, создавать новые разделы, записывать в них что-то. Конфиг используется в виде 'интерфейса' для передачи данных из кода в канал.

|

Config и python
^^^^^^^^^^^^^^^

  - Наш комиссионный сервис является клиентом в ``stream+pub+tcp``, у него есть параметры открытия, с помощью которых он получает исторические данные. Свяжем эти параметры открытия с кодом, ``commission-processor.py``:

    .. code:: yaml

      # ...

        input-channel:
          init:
            # ...

          # за данные открытия мы обращаемся к конфигу у объекта 'logic'
          # мы связываем параметры открытия с разделом конфига 'info'
          # в этом разделе мы создадим подраздел 'input-open-params'
          open: !link /sys/logic/info/input-open-params
          depends: logic

      # ...

  - Объект ``logic`` представляет из себя питоновский код логики, добавим в него несколько строк, ``commission.py``:

    .. code:: python

      from tll.config import Config

      # ...

          def _init(self, url, master=None):

              #...

              # создаём конфиг, который будет являться подразделом в конфиге 'info'
              request_config = Config()
              request_config["mode"] = 'seq'       # 'seq' - режим открытия
              request_config["seq"]  = '0'         # '0' - номер первого запрошенного сообщения

              # в раздел 'info' записываем новый раздел с именем 'input-open-params'
              self.config_info.set("input-open-params", request_config)

      # ...

  - Проверка будет происходить, как и в предыдущей главе: мы запускаем сервер ( генератор сделок ), ждём какое-то время, пока он сгенерирует сообщения, затем запускаем клиент ( сервис комиссий ). В логах будут написаны полученные исторические сообщения, а затем специальное сообщение ``Online``. Можно поменять номер первого сообщения в коде выше, чтобы убедиться, что всё хорошо работает
  - Усложним нашу логику: будем хранить номер последнего полученного сообщения, чтобы при закрытии канала мы могли записать его в конфиг. В момент открытия канала мы сможем считать этот номер из конфига и запросить у сервера все пропущенные из-за отсутсвия связи сообщения, начиная с запомненного номера. Таким образом мы эффективно используем наши ресурсы и не обрабатываем исторические сообщения несколько раз
  - ``commission.py``:

    .. code:: python

      # ...

          def _open(self, props):
              super()._open(props)
        

              # в момент открытия считаем из конфига нужное поле
              self._last_seq = self.config_info["input-open-params.seq"]

              # в конфиге хранятся только строки, поэтому неэффективно будет его использовать с другими типами данных
              # мы храним данные в целочисленной переменной, которой легко манипулировать
              # если кому-то понадобится её значение, то он обратится к конфигу
              # конфиг делегирует запрос callback-функции, которая вернёт строковое представление числа
              self.config_info["input-open-params.seq"] = lambda: str(self._last_seq)
        
        
          def _close(self):
              super()._close()
              
              # в момент закрытия мы снова обновляем значение в конфиге
              # в этот раз там будет храниться просто строка
              # после закрытия может пропасть возможность отработать нормально callback-функции
              self.config_info["input-open-params.seq"] = str(self._last_seq)

          # в _logic(...) с каждым новым полученным сообщением мы пишем self._last_seq = msg.seq + 1
          # self._last_seq по факту хранит в себе номер следующего ожидаемого сообщения

      # ...

Config и С++
^^^^^^^^^^^^

  - Теперь реализуем работу с config в C++, для этого добавим возможность генератору сделок в момент открытия канала выставлять ``id`` следующего генерируемого сообщения. Обновим класс в ``./messages/transaction-generator.h``:

    .. code:: c++

      // ...

          void set_next_transaction_id( int64_t next_tr_id ) {
              _next_transaction_id = next_tr_id;
          }

      // ...

  - ``generator.cc``:

    .. code:: c++

      // ...

          int _init(const tll::Channel::Url &, tll::Channel *master) {

              // ...

              // создаём новый конфиг/раздел
              auto transaction_generator_config = tll::Config();

              // записываем туда значение переменной
              transaction_generator_config.set("next-id", "666");

              // мы можем передать туда не строку, а число, но для этого использовать функцию setT
              // transaction_generator_config.setT("next-id", 666);

              // записываем в раздел 'info' конфига новый раздел
              config_info().set("transaction-generator", transaction_generator_config);
        
              return 0;
          }

          int _open(const tll::ConstConfig &) {

              // вычитываем из конфига в нужный тип данных значение
              // getT возвращает tll::expected, потому что в конфиге могло не быть правильных данных
              // звёздочка возвращает нам запрошенные даныне
              auto next_id = *config_info().getT<int64_t>("transaction-generator.next-id");

              // устанавливаем значение в генераторе
              _transaction_generator.set_next_transaction_id(next_id);
                
              return 0;
          }

      // ...
  - Callback-функции для конфига в C++ имею похожую структуру:

    .. code:: c++

      /* 
        предположим, что у нас есть переменная в классе - _next_id
        _next_id будет каждый раз увеличиваться при генерировании сообщения

        чтобы связать её с конфигом мы напишем строчку:
        config_info().set_ptr("transaction-generator.next-id", &_next_id);

        set_ptr автоматически создаёт callback-функцию, которая берёт значение по ссылке,
        а затем переводит его в C-строку и возвращает

        В таком формате код немного поменяется:
      */

      // ...

          int _open(const tll::ConstConfig &) {
              _next_id = *config_info().getT<int64_t>("transaction-generator.next-id");
              _transaction_generator.set_next_transaction_id(_next_id);
                
              config_info().set_ptr("transaction-generator.next-id", &_next_id);
              
              return 0;
          }
          
          int _close() {
              config_info().setT("transaction-generator.next-id", _next_id);
              return 0;
          }

      // ...
